# HTTP

HTTP는 서버와 클라이언트간의 TCP/IP 통신 위에서 메시지를 교환하기 위해 사용되는 프로토콜이다.

### HTTP/0.9

단순한 서버 클라이언트 구조를 따른다. GET 메서드만 가능하며, HTTP 헤더가 존재하지 않아 HTML 파일만 전송 가능하다. 상태 혹은 오류 코드가 없다.

## HTTP/1.0

**[특징]**

- 기본적으로 한 연결 당 하나의 요청을 처리한다. => RTT 증가
- 버전 정보가 각 요청에 포함된다. => `GET /hello.html HTTP/1.0`
- 상태 코드가 각 응답의 시작 부분에 포함되어, 브라우저 해당 요청에 대한 성공, 실패 여부를 알 수 있다.
- 새로운 HTTP 헤더 (Content-Type)의 등장으로 HTML 파일 이외의 다른 파일도 전송할 수 있게 되었다.

### RTT 증가

서버로 파일을 가져올 때마다 TCP의 3-way handshake를 계속해서 열어야 하기 때문에 RTT가 증가하는 단점이 있다.

> RTT(Round Trip Time)
> : 네트워크 요청을 시작한 후 응답을 받는데 걸리는 시간

---

## HTTP/1.1

HTTP/1.0이 나온지 얼마 되지 않은 후 등장한 HTTP/1.1

**[특징]**

- 매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 이후에 `keep-alive`라는 옵션으로 여러 개의 파일을 송수신할 수 있게 바뀌었다.
- **HOL Blocking** 현상이 발생한다.
- 캐시 제어(Cache Control) 메커니즘이 도입되었다.

### HOL Blocking (Head Of Line Blocking)

앞선 패킷 처리가 지연되면 나머지 다른 패킷들도 연달아 지연되는 현상을 말한다.
HTTP/1.1은 하나의 연결 내에서 하나의 요청을 처리하도록 설계되었기 때문에 순차적으로 처리해야 한다. 따라서 여러 요청을 처리하는데 단점이 있다.

**파이프라이닝**이라는 <U>하나의 커넥션에서 응답을 기다리지 않고 순차적으로 여러 요청을 연속적으로 보내는 방법</U>을 도입하였지만, **응답은 FIFO(First In First Out)로 전송**되어야 하기 때문에 서버로 먼저 온 요청의 응답이 지연되면 다음 요청들의 응답도 덩달아 지연된다.

### 캐시 제어 (Cache-Control) 메커니즘

요청과 응답에 대한 메타 정보를 담는 것이다.
클라이언트가 이전에 받은 데이터와 동일한 데이터를 요청한다면, **Cache-Control을 사용해서 네트워크를 거치지 않고 브라우저가 캐시에서 요청한 데이터를 찾아 클라이언트에게 빠르게 제공**할 수 있다.

---

## HTTP/2

HTTP/1.1이 한 연결 당 하나의 요청을 처리하도록 설계되어 있어 발생하는 여러 단점을 개선하기 위해 나온 프로토콜이다.

**[특징]**

- SPDY 프로토콜을 기반으로 동작한다.
- **멀티플렉싱**을 지원한다.
- 헤더 압축을 지원한다.
- 서버 푸쉬를 지원한다.

### SPDY 프로토콜

'speedy'라는 단어를 기반으로 하여 구글이 만든 프로토콜로, 웹 페이지 로드 대기 시간을 줄이기 위한 목적으로 만든 것이다.

SPDY는 TLS(Transport Layer Security) 위에서 동작하기 때문에, HTTPS로 작성된 웹 사이트만 적용 가능하다.

이러한 SPDY 프로토콜을 표준화한 것이 HTTP/2이다.

### 멀티 플렉싱

> - HTTP/1.x에서는 HTTP 메시지를 평문(텍스트) 형태로 전송한다.
> - HTTP/2에서는 HTTP 메시지의 헤더와 데이터를 **frame**이라는 단위로 나눠 전송하며, 텍스트가 아닌 **binary**로 인코딩하여 전송한다.
>   => 바이너리 형식으로 바꿔보내기 때문에 컴퓨터는 더 빨리 처리할 수 있어 속도가 향상된다.

HTTP 헤더 메시지를 바이너리 형태의 프레임으로 나누고 <U>하나의 커넥션으로 동시에 여러 개의 메시지 스트림을 응답 순서에 상관없이 주고 받는 것</U>을 **multiplexing**이라 한다.

이를 통해 **HTTP/1.1의 큰 단점인 HOL Blocking 문제를 해결**하였다.
![img](https://hpbn.co/assets/diagrams/47ba5b32e42cf5a06c3741d29ef9b94a.svg)

- 위그림 처럼 하나의 커넥션에 여러 병렬 스트림(3개)이 존재할 수 있다.
- 스트림이 뒤섞여서 전송될 경우, stream number를 이용해 수신측에서 재조합된다.
- 응답 프레임들은 요청 순서에 상관없이 먼저 완료된 순서대로 클라이언트에 전달 가능하기 때문에 먼저 온 요청부터 처리해야하는 HOL Blocking 문제를 해결할 수 있게 된 것이다.

### 헤더 압축

이전 Header의 내용과 **중복되는 필드를 재전송하지 않고** 연속된 요청 사이의 매우 유사한 내용으로 존재하는 헤더들을 압축시킨다.

- 메시지 헤더에 중복값이 존재하는 경우 Static/Dynamic table 개념을 도입하여 중복 헤더를 검출한다.
- 중복된 헤더는 index 값만 전송한다.
- 중복되지 않은 header의 정보 값은 허프만 인코딩 기법을 사용한 HPACK 압축 방식으로 인코딩 처리하여 전송한다.

### 서버 푸쉬

클라이언트의 요청을 예상하여 클라이언트 캐시에 **클라이언트가 요청할 것 같은 데이터(리소스)를 미리 넣어두는 기술**이다.

html에는 css나 js 파일이 포함되기 마련인데 html을 읽으면서 그 안에 들어 있던 css 파일을 서버에서 푸시하여 클라이언트에 먼저 줄 수 있다.

---

## HTTPS

**[특징]**

- HTTPS는 HTTP 위에 SSL/TLS 계층을 추가해 통신을 암호화한 프로토콜이다.
  - HTTP은 평문 텍스트, 즉 암호화되지 않은 텍스트를 전송하는 프로토콜로, 중간자 공격에 취약하다.
  - 이러한 보안 문제를 해결해주는 것이 HTTPS
- 공개키 암호화 알고리즘 방식을 사용한다.
- HTTPS는 SEO에 도움이 된다.

### SSL/TLS

TLS(Transport Layer Security)는 SSL(Secure Socket Layer)에서 발전한 것이다. 하지만 거의 같기 때문에 보통 이를 합쳐 SSL/TLS로 많이 부른다.

SSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜로, 클라이언트가 서버와 통신할 때 SSL/TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 한다.

주요 목표는 기밀성, 데이터 무결성, 인증서를 통한 인증을 제공하는 것이다.

### 공개키(비대칭키) 암호화 방식

공개키 암호화 방식에서는 공개키와 비밀키 두 개의 키를 사용하고, 공개키를 이용해서 암호화하고 비밀키를 이용해서 복호화한다. 공개키로 암호화한 데이터는 비밀키로만 복호화할 수 있기 때문에 여러 사람이 공유하는 공개키가 유출되어도 아무런 문제가 없다.

### SEO에 도움이 되는 HTTPS

구글은 SSL 인증서를 강조해왔고 사이트 내 모든 요소가 동일하다면 HTTPS 서비스를 하는 사이트가 그렇지 않은 사이트보다 SEO 순위가 높을 것이라고 공식적으로 밝혔다.

SEO(Search Engine Optimization)는 검색엔진 최적화를 뜻하며 사용자들이 검색엔진으로 웹사이트를 검색했을 때 그 결과를 페이지 상단에 노출시켜 많은 사람이 볼 수 있도록 최적화하는 방법을 의미한다.

---

## HTTP/3

HTTP/2.0가 멀티플렉싱, 헤더 압축, 서버 푸쉬 등으로 처리 속도를 향상 시켰지만 여전히 TCP 기반 통신이라 핸드쉐이크 과정에서 발생하는 지연 시간 문제가 있었기에 이를 개선하고자 HTTP/3이 나오게 되었다.
**[특징]**

- QUIC이라는 계층 위에서 돌아가며, TCP 기반이 아닌 **UDP 기반**으로 돌아간다.
- 멀티플렉싱 지원
- 초기 연결 설정 시 지연 시간 감소

### 초기 연결 설정 시 지연 감소

QUIC은 TCP를 사용하지 않기 때문에 **통신이 시작할 때 번거로운 3-way handshake 과정을 거치지 않아도** 된다. 따라서 1-RTT만 소요된다. 또한, <U>첫 연결 설정에서 필요한 정보와 함께 데이터도 보낸다.</U>

또한, 한 번 연결에 성공했다면 서버는 그 설정을 캐싱해놓고 있다가, 다음 연결 때 키시를 불러와 바로 연결하기 때문에 추가적인 핸드 쉐이크 없이 0 RTT 만으로 통신을 시작할 수도 있다는 장점이 있다.

### **QUIC (Quick UDP Internet Connections)**

- **UDP 기반 전송**
- 1-RTT로 첫 연결 설정하면 그 이후엔 0-RTT로 연결 설정 가능
- TLS 1.3를 사용한 데이터 암호화 프로토콜이 기본 적용이 되어 있음.
- 독립 스트림으로 향상된 멀티 플렉싱 지원 → TCP HOL Blocking 문제 해결

### TCP 자체의 HOL Blocking

HTTP/2에서 HTTP/1.1의 파이프라이닝 HOL Blocking 문제를 파이프라이닝을 해결했다고 했지만, 기본적으로 TCP는 패킷이 유실되거나 오류가 있을 때 재전송하는데 TCP 특성 상 **연결 내 데이터 순서가 보장**되어야 하기 때문에 하나의 패킷이 손실되면 그 이후의 모든 데이터가 재전송될 때까지 대기해야 한다.

따라서 **한 스트림에서 패킷 손실이 발생하면 다른 스트림까지도 영향을 받아 지연**되는 문제가 발생한다.

![img](https://avenash-kumar.com/assets/blogs/images/multplexing-1000x579.png)

QUIC에서는 하나의 연결에서 여러 독립된 스트립을 지원한다. 그림에서 볼 수 있듯 스트림 A에서 패킷이 손실되더라도 스트림 B와 C는 지연없이 계속 데이터 전송을 진행할 수 있다.
