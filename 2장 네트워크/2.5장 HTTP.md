# HTTP

HTTP는 서버와 클라이언트간의 TCP/IP 통신 위에서 메시지를 교환하기 위해 사용되는 프로토콜이다.

**HTTP/0.9**

- 단순한 서버 클라이언트 구조를 따른다.
- GET 메서드만 가능하며, HTTP 헤더가 존재하지 않아 HTML 파일만 전송 가능하다.
- 상태 혹은 오류 코드가 없다.
  <br/>

# HTTP/1.0

**[특징]**

- 기본적으로 한 연결 당 하나의 요청을 처리한다. => RTT 증가
- 버전 정보가 각 요청에 포함된다. => `GET /hello.html HTTP/1.0`
- 상태 코드가 각 응답의 시작 부분에 포함되어, 브라우저 해당 요청에 대한 성공, 실패 여부를 알 수 있다.
- 새로운 HTTP 헤더 (Content-Type)의 등장으로 HTML 파일 이외의 다른 파일도 전송할 수 있게 되었다.

### RTT 증가

- 서버로 파일을 가져올 때마다 TCP의 3-way handshake를 계속해서 열어야 한다.
  - RTT(Round Trip Time)가 증가한다.
    <br/>

# HTTP/1.1

HTTP/1.0이 나온지 얼마 되지 않은 후 등장하였다.

**[특징]**

- 매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 이후에 `keep-alive`라는 옵션으로 여러 개의 파일을 송수신할 수 있게 바뀌었다.
- **HOL Blocking** 현상이 발생한다.
- 캐시 제어(Cache Control) 메커니즘이 도입되었다.

### HOL Blocking (Head Of Line Blocking)

- HTTP/1.1은 하나의 연결 내에서 하나의 요청을 처리하도록 설계되었다.
- 요청을 순차적으로 처리해야 하기 때문에 **앞선 패킷 처리가 지연되면 나머지 다른 패킷들도 연달아 지연되는 현상**이 발생한다.
- 이를 HOL Blocking 현상이라고 한다.

#### 파이프라이닝

- 하나의 커넥션에서 응답을 기다리지 않고 순차적으로 여러 요청을 연속적으로 보내는 방법을 말한다.
- HOL Blocking 현상을 개선하기 위해 도입하였다.
- 하지만, 요청한 순서에 따라 **응답이 FIFO(First In First Out)로 전송**되기 때문에 서버로 먼저 온 요청의 응답이 지연되면 다음 요청들의 응답도 덩달아 지연된다.
  => 결과적으로 파이프라이닝으로 HOL Blocking 현상을 해결할 수 없다.

### 캐시 제어 (Cache-Control) 메커니즘

- 요청과 응답에 대한 메타 정보를 담는 것이다.
- 클라이언트가 이전에 받은 데이터와 동일한 데이터를 요청한다면, **Cache-Control을 사용해서 네트워크를 거치지 않고 브라우저가 캐시에서 요청한 데이터를 찾아 클라이언트에게 빠르게 제공**할 수 있다.
- 서버는 그만큼 클라이언트의 요청이 줄어 부하를 줄일 수 있다.
  <br/>

# HTTP/2

HTTP/1.1이 한 연결 당 하나의 요청을 처리하도록 설계되어 있어 발생하는 여러 단점을 개선하기 위해 나온 프로토콜이다.

**[특징]**

- **SPDY 프로토콜을 기반으로 동작**한다.
- **멀티플렉싱**을 지원한다.
- **헤더 압축**을 지원한다.
- **서버 푸쉬**를 지원한다.

### SPDY 프로토콜

![img](https://d2.naver.com/content/images/2015/06/helloworld-140351-1.png)

- 'speedy'라는 단어를 기반으로 하여 구글이 만든 프로토콜이다.
  - 웹 페이지 로드 대기 시간을 줄이기 위한 목적으로 만들었다.
- 그림에서처럼 SPDY는 TLS(Transport Layer Security) 위에서 동작하기 때문에, HTTPS로 작성된 웹 사이트만 적용 가능하다.
- SPDY 프로토콜을 표준화한 것이 HTTP/2이다.

### 멀티 플렉싱

> - HTTP/1.x에서는 HTTP 메시지를 평문(텍스트) 형태로 전송한다.
> - HTTP/2에서는 HTTP 메시지의 헤더와 데이터를 **frame**이라는 단위로 나눠 전송하며, 텍스트가 아닌 **binary**로 인코딩하여 전송한다.
>   => 바이너리 형식으로 바꿔보내기 때문에 컴퓨터가 더 빨리 처리할 수 있어 속도가 향상된다.

<img src="https://hpbn.co/assets/diagrams/8e6931bb40fc26c511ad15645e7b6113.svg" width="500"/>

HTTP 헤더 메시지를 바이너리 형태의 프레임으로 나누고 <U>하나의 커넥션으로 동시에 여러 개의 메시지 스트림을 응답 순서에 상관없이 주고 받는 것</U>을 **multiplexing**이라 한다.

<img src="https://hpbn.co/assets/diagrams/47ba5b32e42cf5a06c3741d29ef9b94a.svg" width="600"/>

- HTTP 메시지를 독립된 프레임 단위로 분해한다.
- 프레임을 스트림에 인터리빙(끼워넣기)하여 전송하고, 받은 쪽에서는 각 프레임에 있는 스트림 번호를 보고 재조합한다.
- 서버에서 먼저 준비된 응답부터 클라이언트에 전달이 가능하기 때문에 요청한 순서와 상관없이 빠르게 응답을 받을 수 있다.

이를 통해 **HTTP/1.1의 큰 단점인 순차적 HOL Blocking 문제를 해결**할 수 있다.

### 헤더 압축

<img src="https://i.imgur.com/3IPWXvR.png" width="600" />

이전 Header의 내용과 **중복되는 필드를 재전송하지 않고** 연속된 요청 사이의 매우 유사한 내용으로 존재하는 헤더들을 압축시킨다.

- 메시지 헤더에 중복값이 존재하는 경우 Static/Dynamic table 개념을 도입하여 중복 헤더를 검출한다.
- 중복된 헤더는 index 값만 전송한다.
- 중복되지 않은 header의 정보 값은 허프만 인코딩 기법을 사용한 HPACK 압축 방식으로 인코딩 처리하여 전송한다.

### 서버 푸쉬

- 클라이언트의 요청을 예상하여 클라이언트 캐시에 **클라이언트가 요청할 것 같은 데이터(리소스)를 미리 넣어두는 기술**이다.
- html에는 css나 js 파일이 포함되기 마련이다.
- 클라이언트가 html을 요청하면 서버는 그 안에 들어있던 css나 js 파일을 클라이언트가 요청하지 않아도 먼저 줄 수 있다.
  <br/>

# HTTPS

**[특징]**

- HTTPS는 HTTP 위에 SSL/TLS 계층을 추가해 통신을 암호화한 프로토콜이다.
  - HTTP은 평문 텍스트, 즉 암호화되지 않은 텍스트를 전송하는 프로토콜로, 중간자 공격에 취약하다.
  - 이러한 보안 문제를 해결해주는 것이 HTTPS이다.
- 공개키 암호화 알고리즘 방식을 사용한다.
- HTTPS는 SEO에 도움이 된다.

### SSL/TLS

- TLS(Transport Layer Security)는 SSL(Secure Socket Layer)에서 발전한 것이다.

  - 하지만 거의 같기 때문에 보통 이를 합쳐 SSL/TLS로 많이 부른다.

- SSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜이다.
- 클라이언트가 서버와 통신할 때 SSL/TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 한다.
- 주요 목표는 기밀성, 데이터 무결성, 인증서를 통한 인증을 제공하는 것이다.

### 공개키(비대칭키) 암호화 방식

- 공개키와 비밀키 두 개의 키를 사용한다.
- 공개키를 이용해서 암호화하고 비밀키를 이용해서 복호화한다.
- 여러 사람이 공유하는 공개키가 유출되어도 아무런 문제가 없다.

#### DH(Diffie-Hellman) 비밀키 교환 방식

- 암호화에는 공개키를, 복호화에는 비밀키를 이용하는 공개키 암호화 방식의 효시가 되는 방식이다.
- 두 사용자가 번거로움 없이 **비밀키를 교환**할 수 있는 방식을 **Diffie-Hellman 비밀키 교환 방식**이라고 한다.

$$
y = g^xmod p
$$

<img src="https://thebook.io/img/080326/125_2.jpg" width="350">

1. 처음에 공개 값을 공유한다.
2. 각자의 비밀값과 혼합한 후 혼합 값을 공유한다.
3. 공유한 혼합 값을 각자의 비밀값과 혼합해서 공통의 암호키를 생성한다.

이렇게 하여 클라이언트와 서버 모두 개인키와 공개키를 생성하고 서로에게 공개키를 보내고 공개키와 개인키를 결합하여 PSK(사전 합의된 비밀키)가 생성된다면, 악의적인 공격자가 개인키 또는 공개키를 가지고도 PSK가 없기 때문에 아무것도 할 수 없다.

### SEO에 도움이 되는 HTTPS

- 구글은 사이트 내 모든 요소가 동일하다면 HTTPS 서비스를 하는 사이트가 그렇지 않은 사이트보다 SEO 순위가 높을 것이라고 공식적으로 밝혔다.
- SEO(Search Engine Optimization)는 검색엔진 최적화를 뜻하며 사용자들이 웹사이트를 검색했을 때 그 결과를 페이지 상단에 노출시키는 것이다.
  <br/>

# HTTP/3

HTTP/2.0가 멀티플렉싱, 헤더 압축, 서버 푸쉬 등으로 처리 속도를 향상 시켰지만 여전히 TCP 기반 통신이라 핸드쉐이크 과정에서 발생하는 지연 시간 문제가 있었기에 이를 개선하고자 HTTP/3이 나오게 되었다.

**[특징]**

- **QUIC**이라는 계층 위에서 돌아가며, TCP 기반이 아닌 **UDP 기반**으로 돌아간다.
- 멀티플렉싱을 지원한다.
- 초기 연결 설정 시 지연 시간이 감소하였다.

### 초기 연결 설정 시 지연 시간 감소

- QUIC은 TCP를 사용하지 않기 때문에 **통신이 시작할 때 번거로운 3-way handshake 과정을 거치지 않아도** 된다.
  - **1-RTT만 소요**된다.
- 첫 연결 설정에서 필요한 정보와 함께 데이터도 보낸다.
  - TCP에서는 연결 설정이 되어야 데이터를 보낼 수 있었다.
  - 첫 연결 설정부터 데이터를 보내기 때문에 응답이 빠르게 일어날 수 있다.
- 한 번 연결에 성공했다면 **서버는 그 설정을 캐싱해놓고 있다가, 다음 연결 때 캐시를 불러와 바로 연결**한다.
  - 추가적인 핸드쉐이크 없이 **0 RTT 만으로 통신을 시작**할 수도 있다.

### **QUIC (Quick UDP Internet Connections)**

- **UDP 기반 전송**이 이루어진다.
- 1-RTT로 첫 연결 설정하면 그 이후엔 0-RTT로 연결 설정 가능하다.
- TLS 1.3를 사용한 데이터 암호화 프로토콜이 기본 적용이 되어 있다.
- 독립 스트림으로 향상된 멀티 플렉싱을 지원한다.
  - **TCP HOL Blocking 문제를 해결**하였다.

### TCP 자체의 HOL Blocking

- TCP는 패킷이 유실되거나 오류가 있을 때 재전송한다.
- TCP는 특성 상 **연결 내 데이터 순서가 보장**되어야 한다.
- 하나의 패킷이 손실되면 그 이후의 모든 데이터가 재전송될 때까지 대기해야 한다.

따라서 **한 스트림에서 패킷 손실이 발생하면 다른 스트림까지도 영향을 받아 지연**되는 문제가 발생한다.

<img src="https://avenash-kumar.com/assets/blogs/images/multplexing-1000x579.png" width="600"/>

- QUIC에서는 하나의 연결에서 여러 독립된 스트림을 지원한다.
- 그림에서 볼 수 있듯 스트림 A에서 패킷이 손실되더라도 스트림 B와 C는 지연없이 계속 데이터 전송을 진행할 수 있다.

하나의 스트림에서 패킷 손실이 발생하더라도 다른 스트림에는 영향을 주지 않기 때문에 **TCP 자체의 HOL Blocking 문제를 해결**할 수 있다.

---
# 면접 예상 질문
- HTTP와 HTTPS의 차이점은 무엇인가요?
- HTTP 1.0과 1.1의 차이점을 설명하세요.
- HTTP/1.x와 비교하여 HTTP/2에서 개선된 점은 무엇인가요?
- 멀티플렉싱이란 무엇인가요?
- HTTPS를 사용하는 이유에 대해 설명해주세요.
- HTTPS 의 SSL/TLS에 대해 설명해주세요.

### 이미지 출처

- [spdy 프로토콜 이미지](https://d2.naver.com/content/images/2015/06/helloworld-140351-1.png)
- [multiplexing](https://hpbn.co/assets/diagrams/8e6931bb40fc26c511ad15645e7b6113.svg)
- [헤더압축](https://i.imgur.com/3IPWXvR.png)
- [QUIC](https://avenash-kumar.com/assets/blogs/images/multplexing-1000x579.png)
